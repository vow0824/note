引用自：https://blog.csdn.net/qq_33591903/article/details/120582131

对三级缓存的理解

在单线程的情况，也就是getBean仅支持串行操作的话，那么一级缓存其实已经够用了。

二级缓存将半成品与成品对象分离，使得多线程的情况下，不会拿到不完整的对象实例。而且支持多线程同时查询缓存，在一定程度上提升了性能。

三级缓存存放的是单例对象工厂，准确的说，是函数式接口实现，是生成对象的一段逻辑。如果该对象被代理，则工厂的getObject返回代理之后的对象，否则返回原对象。

这里可能有人有疑问，为什么需要三级缓存呢？在实例化阶段之后，直接将原对象或代理对象放入二级缓存不也行吗？

理论是可以的。

一般来说，在Bean的生命周期中，创建代理是在初始化完成后再做的。

而如果代理出现在循环依赖中，不能等到初始化完成后再做，否则B中注入的A就是原对象，不是代理对象。因此，需要在B的属性注入的前一刻完成对A的代理，而这个阶段，也必然是发生在A的初始化之前。

这个时候，大可以在A实例化之后，如果存在特定的后置处理器，也就是说存在代理，那么直接将A的代理对象放入二级缓存中，不管以后会不会出现循环依赖。事实上，在这个时期，也无法去检测到底之后会不会产生循环依赖，总不能去预知未来吧。如果出现循环依赖，则从二级缓存中获取A的代理对象，注入到B中，这个时候是可以的。如果不发生循环依赖，这个A的代理对象就是无用的，做的是无用功。

这个时候，再加上一层缓存呢？在A实例化之后，只往三级缓存中存放一个生成对象的逻辑。到底是生成代理对象还是原对象，由发生循环依赖时再做决定。当发生循环依赖时，例如当B中需要注入A时，会调用三级缓存中的工厂逻辑，生成A的代理对象，注入进B中。当没发生循环依赖时，A的代理对象还是在初始化完成之后再做，和Bean的生命周期中的处理一致。

所以，三级缓存的存在，是由于对代理的考虑。一方面能避免直接在二级缓存中存放代理对象而之后没发生循环依赖所做的无用功，另一方面也能够最大化的统一Bean的生命周期，可谓两全其美，一箭双雕。